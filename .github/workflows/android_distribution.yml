# This is the name that shows up in the GitHub Actions tab
name: Build and Distribute Android App to Firebase

# WHEN should this automation run?
on:
  # Run whenever someone pushes directly to the main branch
  push:
    branches:
      - main  # Changed from 'prod' to 'main'
  # ALSO run when a Pull Request is closed (merged or just closed)
  pull_request:
    branches:
      - main  # Changed from 'prod' to 'main'
    types: [closed]  # Only trigger when PR is closed, not opened/updated

# Define the actual work to be done
jobs:
  build_and_distribute:
    # This condition prevents the job from running on EVERY PR close
    # It only runs if:
    # 1. Someone pushed directly to main, OR
    # 2. A pull request was actually MERGED (not just closed without merging)
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)
    
    # Use a Linux virtual machine to run this job (free on GitHub)
    runs-on: ubuntu-latest
    
    # List of sequential steps to execute
    steps:
    # Step 1: Download your code from the repository
    - name: Checkout code
      uses: actions/checkout@v4  # This is a pre-built action from GitHub
    
    # Step 2: Install Java 17 (required for Android app building)
    - name: Set up Java
      uses: actions/setup-java@v4  # Another pre-built action
      with:
        distribution: 'zulu'  # Which Java distribution to use
        java-version: '17'    # Android requires Java 17 for newer builds
    
    # Step 3: Install Flutter SDK on the virtual machine
    - name: Set up Flutter
      uses: subosito/flutter-action@v2  # Community-created action for Flutter
      with:
        channel: 'stable'  # Use the stable release channel (not beta/dev)
    
    # Step 4: Download all the dependencies your Flutter app needs
    - name: Install Flutter dependencies
      run: flutter pub get  # Same command you run locally
    
    # Step 5: Decode Keystore File and Setup Signing Properties ðŸ”’
    # This step is REQUIRED for Firebase App Distribution (unsigned APKs are rejected)
    - name: Decode Keystore and Setup Signing
      env:
        KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
      run: |
        # Decode the base64-encoded keystore file
        echo $KEYSTORE_BASE64 | base64 --decode > android/app/release.jks
        # Create key.properties file for signing configuration
        echo "storeFile=release.jks" > android/key.properties
        echo "keyAlias=$KEY_ALIAS" >> android/key.properties
        echo "storePassword=$KEYSTORE_PASSWORD" >> android/key.properties
        echo "keyPassword=$KEY_PASSWORD" >> android/key.properties
        # Move key.properties to the correct location
        mv android/key.properties android/app/key.properties
        echo "Signing configuration files created."
    
    # Step 6: Build the actual Android APK file (SIGNED)
    - name: Build Android Release APK
      run: flutter build apk --release  # Creates the installable .apk file
      # This APK gets saved to: build/app/outputs/flutter-apk/app-release.apk
      # The APK is automatically signed using the keystore from Step 5
    
    # Step 7: Install Firebase command-line tools
    - name: Set up Firebase CLI
      run: npm install -g firebase-tools  # Install globally using npm
    
    # Step 8: Upload the built APK to Firebase App Distribution
    - name: Distribute to Firebase App Distribution
      run: |
        # This is a multi-line command
        firebase appdistribution:distribute build/app/outputs/flutter-apk/app-release.apk \
          --app ${{ secrets.FIREBASE_APP_ID }} \
          --release-notes "Build from commit ${{ github.sha }} by ${{ github.actor }}" \
          --groups "testers"
        # Explanation of the above command:
        # - firebase appdistribution:distribute: Upload to App Distribution
        # - build/app/outputs/flutter-apk/app-release.apk: Path to the APK we just built
        # - --app: Which Firebase app to upload to (from GitHub secrets)
        # - --release-notes: Description shown to testers (includes commit hash and who triggered it)
        # - --groups "testers": Send to the "testers" group you created in Firebase
      env:
        # Provide the Firebase authentication token from GitHub secrets
        FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
        # This token allows the CLI to authenticate with Firebase without manual login

# SUMMARY OF WHAT HAPPENS:
# 1. Someone pushes to main or merges a PR
# 2. GitHub spins up a Linux computer in the cloud
# 3. Downloads your code
# 4. Installs Java and Flutter
# 5. Downloads your app's dependencies
# 6. Decodes your keystore and sets up signing configuration
# 7. Builds your Flutter app into a SIGNED Android APK
# 8. Installs Firebase tools
# 9. Uploads the SIGNED APK to Firebase App Distribution
# 10. Firebase sends email notifications to your "testers" group
# 11. Testers can download and install the APK on their phones
# 12. The virtual machine is destroyed (you don't pay for it after the job finishes)