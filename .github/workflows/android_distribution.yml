# This is the name that shows up in the GitHub Actions tab
name: Build and Distribute Android App to Firebase

# WHEN should this automation run?
on:
  # Run whenever someone pushes directly to the main branch
  push:
    branches:
      - main  # Changed from 'prod' to 'main'
  # ALSO run when a Pull Request is closed (merged or just closed)
  pull_request:
    branches:
      - main  # Changed from 'prod' to 'main'
    types: [closed]  # Only trigger when PR is closed, not opened/updated

# Define the actual work to be done
jobs:
  build_and_distribute:
    # This condition prevents the job from running on EVERY PR close
    # It only runs if:
    # 1. Someone pushed directly to main, OR
    # 2. A pull request was actually MERGED (not just closed without merging)
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)
    
    # Use a Linux virtual machine to run this job (free on GitHub)
    runs-on: ubuntu-latest
    
    # List of sequential steps to execute
    steps:
    # Step 1: Download your code from the repository
    - name: Checkout code
      uses: actions/checkout@v4  # This is a pre-built action from GitHub
    
    # Step 2: Install Java 17 (required for Android app building)
    - name: Set up Java
      uses: actions/setup-java@v4  # Another pre-built action
      with:
        distribution: 'zulu'  # Which Java distribution to use
        java-version: '17'    # Android requires Java 17 for newer builds
    
    # Step 3: Install Flutter SDK on the virtual machine
    - name: Set up Flutter
      uses: subosito/flutter-action@v2  # Community-created action for Flutter
      with:
        channel: 'stable'  # Use the stable release channel (not beta/dev)
    
    # Step 4: Download all the dependencies your Flutter app needs
    - name: Install Flutter dependencies
      run: flutter pub get  # Same command you run locally
    
    # Step 5: Generate or Decode Keystore File ðŸ”’
    - name: Setup Keystore
      env:
        KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
      run: |
        # Check if KEYSTORE_BASE64 secret exists
        if [ -n "$KEYSTORE_BASE64" ]; then
          echo "Using existing keystore from secrets..."
          echo "$KEYSTORE_BASE64" | base64 --decode > android/app/upload-keystore.jks
        else
          echo "âš ï¸ No keystore found in secrets. Generating a new one..."
          echo "âš ï¸ THIS IS FOR TESTING ONLY - You should save this keystore for production!"
          
          # Generate a new keystore
          keytool -genkey -v \
            -keystore android/app/upload-keystore.jks \
            -keyalg RSA \
            -keysize 2048 \
            -validity 10000 \
            -alias upload \
            -storepass android \
            -keypass android \
            -dname "CN=MUN Thrift, OU=Development, O=MUN, L=St. Johns, S=NL, C=CA"
          
          echo ""
          echo "ðŸ“‹ IMPORTANT: Add these to your GitHub Secrets for future builds:"
          echo "1. KEYSTORE_BASE64: (run this locally after downloading the keystore)"
          echo "   base64 -w 0 android/app/upload-keystore.jks"
          echo "2. KEYSTORE_PASSWORD: android"
          echo "3. KEY_ALIAS: upload"
          echo "4. KEY_PASSWORD: android"
          
          # Encode and display the keystore (for you to copy to secrets)
          echo ""
          echo "ðŸ”‘ Base64 Encoded Keystore (copy this to KEYSTORE_BASE64 secret):"
          base64 -w 0 android/app/upload-keystore.jks
          echo ""
        fi
        
        # Create key.properties file for signing configuration
        STORE_PASS="${KEYSTORE_PASSWORD:-android}"
        KEY_PASS="${KEY_PASSWORD:-android}"
        ALIAS="${KEY_ALIAS:-upload}"
        
        echo "storeFile=upload-keystore.jks" > android/app/key.properties
        echo "keyAlias=$ALIAS" >> android/app/key.properties
        echo "storePassword=$STORE_PASS" >> android/app/key.properties
        echo "keyPassword=$KEY_PASS" >> android/app/key.properties
        echo "âœ… Signing configuration files created."
    
    # Step 6: Build the actual Android APK file (SIGNED)
    - name: Build Android Release APK
      run: flutter build apk --release  # Creates the installable .apk file
      # This APK gets saved to: build/app/outputs/flutter-apk/app-release.apk
      # The APK is automatically signed using the keystore from Step 5
    
    # Step 7: Install Firebase command-line tools
    - name: Set up Firebase CLI
      run: npm install -g firebase-tools  # Install globally using npm
    
    # Step 8: Upload the built APK to Firebase App Distribution
    - name: Distribute to Firebase App Distribution
      run: |
        # This is a multi-line command
        firebase appdistribution:distribute build/app/outputs/flutter-apk/app-release.apk \
          --app ${{ secrets.FIREBASE_APP_ID }} \
          --release-notes "Build from commit ${{ github.sha }} by ${{ github.actor }}" \
          --groups "testers"
        # Explanation of the above command:
        # - firebase appdistribution:distribute: Upload to App Distribution
        # - build/app/outputs/flutter-apk/app-release.apk: Path to the APK we just built
        # - --app: Which Firebase app to upload to (from GitHub secrets)
        # - --release-notes: Description shown to testers (includes commit hash and who triggered it)
        # - --groups "testers": Send to the "testers" group you created in Firebase
      env:
        # Provide the Firebase authentication token from GitHub secrets
        FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
        # This token allows the CLI to authenticate with Firebase without manual login

# SUMMARY OF WHAT HAPPENS:
# 1. Someone pushes to main or merges a PR
# 2. GitHub spins up a Linux computer in the cloud
# 3. Downloads your code
# 4. Installs Java and Flutter
# 5. Downloads your app's dependencies
# 6. Either decodes existing keystore OR generates a new one automatically
# 7. Builds your Flutter app into a SIGNED Android APK
# 8. Installs Firebase tools
# 9. Uploads the SIGNED APK to Firebase App Distribution
# 10. Firebase sends email notifications to your "testers" group
# 11. Testers can download and install the APK on their phones
# 12. The virtual machine is destroyed (you don't pay for it after the job finishes)